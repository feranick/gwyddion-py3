<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>File Modules: Gwyddion Module Library Reference Manual</title>
<meta name="generator" content="DocBook XSL Stylesheets Vsnapshot">
<link rel="home" href="index.html" title="Gwyddion Module Library Reference Manual">
<link rel="up" href="ModuleTutorial.html" title="Gwyddion Module Tutorial">
<link rel="prev" href="gwymodule-tutorial-process.html" title="Data Processing Modules">
<link rel="next" href="gwymodule-tutorial-graph.html" title="Graph Modules">
<meta name="generator" content="GTK-Doc V1.19 (XML mode)">
<link rel="stylesheet" href="style.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table class="navigation" id="top" width="100%" summary="Navigation header" cellpadding="2" cellspacing="5"><tr valign="middle">
<td width="100%" align="left" class="shortcuts"></td>
<td><a accesskey="h" href="index.html"><img src="home.png" width="16" height="16" border="0" alt="Home"></a></td>
<td><a accesskey="u" href="ModuleTutorial.html"><img src="up.png" width="16" height="16" border="0" alt="Up"></a></td>
<td><a accesskey="p" href="gwymodule-tutorial-process.html"><img src="left.png" width="16" height="16" border="0" alt="Prev"></a></td>
<td><a accesskey="n" href="gwymodule-tutorial-graph.html"><img src="right.png" width="16" height="16" border="0" alt="Next"></a></td>
</tr></table>
<div class="refentry">
<a name="gwymodule-tutorial-file"></a><div class="titlepage"></div>
<div class="refnamediv"><table width="100%"><tr>
<td valign="top">
<h2><span class="refentrytitle">File Modules</span></h2>
<p>File Modules â€” 
      More about file modules
    </p>
</td>
<td class="gallery_image" valign="top" align="right"></td>
</tr></table></div>
<div class="refsect1">
<a name="id-1.3.6.3"></a><h2>Overview</h2>
<p>
      File modules implement loading and saving of SPM files.  The structure
      and operation of file modules will be explained on a simple but complete
      sample file module.  This module imports a sample data format that was
      construed for this tutorial and does not occur in practice.  However,
      the format resembles many (binary) data formats used in practice,
      except it contains no device and manufacturer information as they
      are not essential for the example.
    </p>
<p>
      The sample file format our module will load looks as follows, all
      values are stored in little-endian:
      </p>
<div class="informaltable"><table class="informaltable" border="0">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>Position</th>
<th>Type</th>
<th>Name</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td>0x00</td>
<td>
<span class="type">char</span>[4]</td>
<td><code class="varname">magic</code></td>
<td>Magic header <code class="literal">"SMPL"</code>
</td>
</tr>
<tr>
<td>0x04</td>
<td><span class="type">uint16</span></td>
<td><code class="varname">xres</code></td>
<td>Pixels per line</td>
</tr>
<tr>
<td>0x06</td>
<td><span class="type">uint16</span></td>
<td><code class="varname">yres</code></td>
<td>Number of lines</td>
</tr>
<tr>
<td>0x08</td>
<td><span class="type">float</span></td>
<td><code class="varname">measure</code></td>
<td>Size of one pixel [nm]</td>
</tr>
<tr>
<td>0x0c</td>
<td><span class="type">float</span></td>
<td><code class="varname">z0</code></td>
<td>Value corresponding to 0 in raw data [nm]</td>
</tr>
<tr>
<td>0x10</td>
<td><span class="type">float</span></td>
<td><code class="varname">gain</code></td>
<td>
                Conversion factor from raw data to physical values [nm]
              </td>
</tr>
<tr>
<td>0x14</td>
<td>
<span class="type">uint16</span>[<code class="varname">xres</code>*<code class="varname">yres</code>]</td>
<td><code class="varname">data</code></td>
<td>Raw data values</td>
</tr>
</tbody>
</table></div>
<p>
      Furthermore we will assume files of this type get the extension
      <code class="filename">.ssd</code> (Simple SPM Data).  The complete module source
      code follows, it will be described in detail below.
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;glib/gstdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;libgwyddion/gwymacros.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;libgwyddion/gwymath.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;libprocess/stats.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;libgwymodule/gwymodule-file.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;app/gwymoduleutils-file.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;err.h&quot;</span><span class="cp"></span>

<span class="cp">#define EXTENSION &quot;.ssd&quot;</span>

<span class="cp">#define MAGIC &quot;SMPL&quot;</span>
<span class="cp">#define MAGIC_SIZE (sizeof(MAGIC) - 1)</span>

<span class="k">enum</span> <span class="p">{</span> <span class="n">HEADER_SIZE</span> <span class="o">=</span> <span class="n">MAGIC_SIZE</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">4</span> <span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">guint</span> <span class="n">xres</span><span class="p">;</span>
    <span class="n">guint</span> <span class="n">yres</span><span class="p">;</span>
    <span class="n">gdouble</span> <span class="n">measure</span><span class="p">;</span>
    <span class="n">gdouble</span> <span class="n">z0</span><span class="p">;</span>
    <span class="n">gdouble</span> <span class="n">gain</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SimpleFile</span><span class="p">;</span>

<span class="k">static</span> <span class="n">gboolean</span>      <span class="n">module_register</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="n">gint</span>          <span class="n">simple_detect</span>  <span class="p">(</span><span class="k">const</span> <span class="n">GwyFileDetectInfo</span> <span class="o">*</span><span class="n">fileinfo</span><span class="p">,</span>
                                     <span class="n">gboolean</span> <span class="n">only_name</span><span class="p">);</span>
<span class="k">static</span> <span class="n">GwyContainer</span><span class="o">*</span> <span class="n">simple_load</span>    <span class="p">(</span><span class="k">const</span> <span class="n">gchar</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span>
                                     <span class="n">GwyRunType</span> <span class="n">mode</span><span class="p">,</span>
                                     <span class="n">GError</span> <span class="o">**</span><span class="n">error</span><span class="p">);</span>

<span class="k">static</span> <span class="n">GwyModuleInfo</span> <span class="n">module_info</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">GWY_MODULE_ABI_VERSION</span><span class="p">,</span>
    <span class="o">&amp;</span><span class="n">module_register</span><span class="p">,</span>
    <span class="n">N_</span><span class="p">(</span><span class="s">&quot;Imports simple data files.&quot;</span><span class="p">),</span>
    <span class="s">&quot;J. Random Hacker &lt;hacker.jr@example.org&gt;&quot;</span><span class="p">,</span>
    <span class="s">&quot;1.0&quot;</span><span class="p">,</span>
    <span class="s">&quot;Bit Rot Inc.&quot;</span><span class="p">,</span>
    <span class="s">&quot;2006&quot;</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">GWY_MODULE_QUERY</span><span class="p">(</span><span class="n">module_info</span><span class="p">)</span>

<span class="k">static</span> <span class="n">gboolean</span>
<span class="n">module_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">gwy_file_func_register</span><span class="p">(</span><span class="s">&quot;simple&quot;</span><span class="p">,</span>
                           <span class="n">N_</span><span class="p">(</span><span class="s">&quot;Simple AFM files (.afm)&quot;</span><span class="p">),</span>
                           <span class="p">(</span><span class="n">GwyFileDetectFunc</span><span class="p">)</span><span class="o">&amp;</span><span class="n">simple_detect</span><span class="p">,</span>
                           <span class="p">(</span><span class="n">GwyFileLoadFunc</span><span class="p">)</span><span class="o">&amp;</span><span class="n">simple_load</span><span class="p">,</span>
                           <span class="nb">NULL</span><span class="p">,</span>
                           <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">gint</span>
<span class="n">simple_detect</span><span class="p">(</span><span class="k">const</span> <span class="n">GwyFileDetectInfo</span> <span class="o">*</span><span class="n">fileinfo</span><span class="p">,</span>
              <span class="n">gboolean</span> <span class="n">only_name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">only_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g_str_has_suffix</span><span class="p">(</span><span class="n">fileinfo</span><span class="o">-&gt;</span><span class="n">name_lowercase</span><span class="p">,</span> <span class="n">EXTENSION</span><span class="p">)</span> <span class="o">?</span> <span class="mi">20</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fileinfo</span><span class="o">-&gt;</span><span class="n">buffer_len</span> <span class="o">&gt;</span> <span class="n">MAGIC_SIZE</span>
        <span class="o">&amp;&amp;</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">fileinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">MAGIC</span><span class="p">,</span> <span class="n">MAGIC_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">100</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">GwyContainer</span><span class="o">*</span>
<span class="n">simple_load</span><span class="p">(</span><span class="k">const</span> <span class="n">gchar</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span>
            <span class="n">G_GNUC_UNUSED</span> <span class="n">GwyRunType</span> <span class="n">mode</span><span class="p">,</span>
            <span class="n">GError</span> <span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SimpleFile</span> <span class="n">simple</span><span class="p">;</span>
    <span class="n">GwyContainer</span> <span class="o">*</span><span class="n">container</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">GwySIUnit</span> <span class="o">*</span><span class="n">unit</span><span class="p">;</span>
    <span class="n">GwyDataField</span> <span class="o">*</span><span class="n">dfield</span><span class="p">;</span>
    <span class="n">guchar</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">guchar</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="n">GError</span> <span class="o">*</span><span class="n">err</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">gsize</span> <span class="n">size</span><span class="p">,</span> <span class="n">expected_size</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">guint16</span> <span class="o">*</span><span class="n">rawdata</span><span class="p">;</span>
    <span class="n">gdouble</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="n">gint</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gwy_file_get_contents</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">err_GET_FILE_CONTENTS</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
        <span class="n">g_clear_error</span><span class="p">(</span><span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">HEADER_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_TOO_SHORT</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
        <span class="n">gwy_file_abandon_contents</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">MAGIC</span><span class="p">,</span> <span class="n">MAGIC_SIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_FILE_TYPE</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="s">&quot;Simple&quot;</span><span class="p">);</span>
        <span class="n">gwy_file_abandon_contents</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">MAGIC_SIZE</span><span class="p">;</span>
    <span class="n">simple</span><span class="p">.</span><span class="n">xres</span> <span class="o">=</span> <span class="n">gwy_get_guint16_le</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
    <span class="n">simple</span><span class="p">.</span><span class="n">yres</span> <span class="o">=</span> <span class="n">gwy_get_guint16_le</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
    <span class="n">simple</span><span class="p">.</span><span class="n">measure</span> <span class="o">=</span> <span class="n">gwy_get_gfloat_le</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
    <span class="n">simple</span><span class="p">.</span><span class="n">z0</span> <span class="o">=</span> <span class="n">gwy_get_gfloat_le</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
    <span class="n">simple</span><span class="p">.</span><span class="n">gain</span> <span class="o">=</span> <span class="n">gwy_get_gfloat_le</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>

    <span class="n">expected_size</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">simple</span><span class="p">.</span><span class="n">xres</span><span class="o">*</span><span class="n">simple</span><span class="p">.</span><span class="n">yres</span> <span class="o">+</span> <span class="n">HEADER_SIZE</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="n">expected_size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_SIZE_MISMATCH</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="n">expected_size</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
        <span class="n">gwy_file_abandon_contents</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">simple</span><span class="p">.</span><span class="n">measure</span> <span class="o">*=</span> <span class="mf">1e-9</span><span class="p">;</span>
    <span class="n">simple</span><span class="p">.</span><span class="n">z0</span> <span class="o">*=</span> <span class="mf">1e-9</span><span class="p">;</span>
    <span class="n">simple</span><span class="p">.</span><span class="n">gain</span> <span class="o">*=</span> <span class="mf">1e-9</span><span class="p">;</span>
    <span class="n">dfield</span> <span class="o">=</span> <span class="n">gwy_data_field_new</span><span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">xres</span><span class="p">,</span> <span class="n">simple</span><span class="p">.</span><span class="n">yres</span><span class="p">,</span>
                                <span class="n">simple</span><span class="p">.</span><span class="n">xres</span><span class="o">*</span><span class="n">simple</span><span class="p">.</span><span class="n">measure</span><span class="p">,</span>
                                <span class="n">simple</span><span class="p">.</span><span class="n">yres</span><span class="o">*</span><span class="n">simple</span><span class="p">.</span><span class="n">measure</span><span class="p">,</span>
                                <span class="n">FALSE</span><span class="p">);</span>
    <span class="n">gwy_convert_raw_data</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">simple</span><span class="p">.</span><span class="n">xres</span><span class="o">*</span><span class="n">simple</span><span class="p">.</span><span class="n">yres</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                         <span class="n">GWY_RAW_DATA_UINT16</span><span class="p">,</span> <span class="n">GWY_BYTE_ORDER_LITTLE_ENDIAN</span><span class="p">,</span>
                         <span class="n">gwy_data_field_get_data</span><span class="p">(</span><span class="n">dfield</span><span class="p">),</span>
                         <span class="n">simple</span><span class="p">.</span><span class="n">gain</span><span class="p">,</span> <span class="n">simple</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>

    <span class="n">unit</span> <span class="o">=</span> <span class="n">gwy_si_unit_new</span><span class="p">(</span><span class="s">&quot;m&quot;</span><span class="p">);</span>
    <span class="n">gwy_data_field_set_si_unit_xy</span><span class="p">(</span><span class="n">dfield</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
    <span class="n">g_object_unref</span><span class="p">(</span><span class="n">unit</span><span class="p">);</span>

    <span class="n">unit</span> <span class="o">=</span> <span class="n">gwy_si_unit_new</span><span class="p">(</span><span class="s">&quot;m&quot;</span><span class="p">);</span>
    <span class="n">gwy_data_field_set_si_unit_z</span><span class="p">(</span><span class="n">dfield</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
    <span class="n">g_object_unref</span><span class="p">(</span><span class="n">unit</span><span class="p">);</span>

    <span class="n">container</span> <span class="o">=</span> <span class="n">gwy_container_new</span><span class="p">();</span>
    <span class="n">gwy_container_set_object_by_name</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="s">&quot;/0/data&quot;</span><span class="p">,</span> <span class="n">dfield</span><span class="p">);</span>
    <span class="n">gwy_container_set_string_by_name</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="s">&quot;/0/data/title&quot;</span><span class="p">,</span>
                                     <span class="n">g_strdup</span><span class="p">(</span><span class="s">&quot;Topography&quot;</span><span class="p">));</span>
    <span class="n">g_object_unref</span><span class="p">(</span><span class="n">dfield</span><span class="p">);</span>

    <span class="n">gwy_file_channel_import_log_add</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;simple&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>

    <span class="n">gwy_file_abandon_contents</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">container</span><span class="p">;</span>
<span class="p">}</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

</div>
<div class="refsect1">
<a name="id-1.3.6.4"></a><h2>Administrative and Conventions</h2>
<p>
      Beside standard headers our module includes a special header that
      provides some common inline functions
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="cp">#include</span> <span class="cpf">&quot;err.h&quot;</span><span class="cp"></span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
      It is located in <code class="filename">modules/file</code> for the use by
      in-tree modules.  External modules can copy it (or only the
      actually used functions) to their source code.
    </p>
<p>
      Header <code class="filename">err.h</code> contains common error reporting
      functions (called <code class="function">err_ERROR_TYPE</code>).
      Its primary purpose it to ensure consistency of error
      messages between file modules and to ease translators' work.
    </p>
<p>
      Next we define a few convenience symbols: the file extension, the magic
      header and its size, and header size
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="cp">#define EXTENSION &quot;.ssd&quot;</span>

<span class="cp">#define MAGIC &quot;SMPL&quot;</span>
<span class="cp">#define MAGIC_SIZE (sizeof(MAGIC) - 1)</span>

<span class="k">enum</span> <span class="p">{</span> <span class="n">HEADER_SIZE</span> <span class="o">=</span> <span class="n">MAGIC_SIZE</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="mi">4</span> <span class="p">};</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
      We also define a structure representing the imported file.  It is a bit
      superfluous in our module as we do not pass this information around, but
      it is useful in many modules
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6
7</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">guint</span> <span class="n">xres</span><span class="p">;</span>
    <span class="n">guint</span> <span class="n">yres</span><span class="p">;</span>
    <span class="n">gdouble</span> <span class="n">measure</span><span class="p">;</span>
    <span class="n">gdouble</span> <span class="n">z0</span><span class="p">;</span>
    <span class="n">gdouble</span> <span class="n">gain</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SimpleFile</span><span class="p">;</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

</div>
<div class="refsect1">
<a name="id-1.3.6.5"></a><h2>Registration</h2>
<p>
      The feature registration is similar to data processing functions,
      there are just no menu paths and stock icons, on the other hand there are
      more functions the module can provide: one for each file operation.  Our
      module implements only file detection and import therefore we pass
      <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Standard-Macros.html#NULL:CAPS"><code class="literal">NULL</code></a> for the save and export functions.
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6
7
8
9
10
11
12</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="k">static</span> <span class="n">gboolean</span>
<span class="n">module_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">gwy_file_func_register</span><span class="p">(</span><span class="s">&quot;simple&quot;</span><span class="p">,</span>
                           <span class="n">N_</span><span class="p">(</span><span class="s">&quot;Simple AFM files (.afm)&quot;</span><span class="p">),</span>
                           <span class="p">(</span><span class="n">GwyFileDetectFunc</span><span class="p">)</span><span class="o">&amp;</span><span class="n">simple_detect</span><span class="p">,</span>
                           <span class="p">(</span><span class="n">GwyFileLoadFunc</span><span class="p">)</span><span class="o">&amp;</span><span class="n">simple_load</span><span class="p">,</span>
                           <span class="nb">NULL</span><span class="p">,</span>
                           <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
      It is necessary to provide at least one of load, save and export
      operations, otherwise the file type would be rejected.  It is highly
      recommended to provide a detection function, although it is not
      required.  If no detection function exists for a file type the user
      has to always explicitly request the type to load and/or save files
      in this format.
    </p>
</div>
<div class="refsect1">
<a name="id-1.3.6.6"></a><h2>Detection</h2>
<p>
      Two types of detection exist: on load when we have the file
      available, and on save when the file does not exist and we know only
      the requested file name.  They are differentiated by
      <code class="varname">only_name</code> argument.  In both cases the detection
      function gets a <a class="link" href="libgwymodule-gwymodule-file.html#GwyFileDetectInfo" title="GwyFileDetectInfo"><span class="type">GwyFileDetectInfo</span></a> structure, but if
      <code class="varname">only_name</code> is <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Standard-Macros.html#FALSE:CAPS"><code class="literal">FALSE</code></a>, some fields are unset.
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="k">static</span> <span class="n">gint</span>
<span class="n">simple_detect</span><span class="p">(</span><span class="k">const</span> <span class="n">GwyFileDetectInfo</span> <span class="o">*</span><span class="n">fileinfo</span><span class="p">,</span>
              <span class="n">gboolean</span> <span class="n">only_name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">only_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g_str_has_suffix</span><span class="p">(</span><span class="n">fileinfo</span><span class="o">-&gt;</span><span class="n">name_lowercase</span><span class="p">,</span> <span class="n">EXTENSION</span><span class="p">)</span> <span class="o">?</span> <span class="mi">20</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fileinfo</span><span class="o">-&gt;</span><span class="n">buffer_len</span> <span class="o">&gt;</span> <span class="n">MAGIC_SIZE</span>
        <span class="o">&amp;&amp;</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">fileinfo</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">MAGIC</span><span class="p">,</span> <span class="n">MAGIC_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">100</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
      The latter case is usually trivial, we just compare the extension with
      the normal extension of our file type.
    </p>
<p>
      The former case can be more complex.  File name does not tell us much
      about file type: consider just the number of formats using extension
      <code class="filename">.afm</code> (not talking about <code class="filename">.dat</code>
      which can be essentially anything).  Therefore we use file names only
      as the last resort and base the detection on actual file contents.
    </p>
<p>
      Many formats have well defined magic headers, precisely for the puropose
      of easy detection.  If out format has one, we are lucky and the detection
      code can look as simple as in the example.  To detect a particular
      version or type of a file format a more detailed analysis is necessary,
      but not substantially different from the simple case.
    </p>
<p>
      The most problematic case arises when the format has no detectable magic
      header at all.  Often we can employ the following approach: read the
      header data and check whether it makes sense if interpreted as our
      file format.  For example we read the number of lines and pixels per
      line, calculate expected file size and compare it to the real file size.
      Or we read the physical dimensions and check they are positive (and
      approximately of expected magnitude).  If our detection routine requires
      significant processing or <em class="structfield"><code>head</code></em> and
      <em class="structfield"><code>tail</code></em> are not sufficient and we have to open
      the file ourselves, it is advisable to perform a quick check that can
      eliminate most files that are <span class="emphasis"><em>not</em></span> of our type first,
      and then perform the sophisticated test only on the likely candidates.
    </p>
</div>
<div class="refsect1">
<a name="id-1.3.6.7"></a><h2>Loading</h2>
<p>
      The task of the load function is to read the file and create
      a <a href="../GwyContainer.html#GwyContainer-struct"><span class="type">GwyContainer</span></a> containing all importable data. It must not assume
      anything about the file properties and contents, not even that the file
      passed the detection because the user can request a file type
      explicitly, bypassing detection.  It has also deal with broken files,
      checking whether the file is long enough to contain the data it claims
      to and performing further parameter validation if necessary.
    </p>
<p>
      The file contents can be often read with <a href="../libgwyddion-gwyutils.html#gwy-file-get-contents"><code class="function">gwy_file_get_contents()</code></a> which
      uses <code class="function">mmap()</code> (if available).  The returned memory
      is read-only.  Sometimes destructive header parsing is useful, in such
      a case it is possible to use <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Memory-Allocation.html#g-memdup"><code class="function">g_memdup()</code></a> to duplicate the header,
      keeping the data part mapped read-only.
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">HEADER_SIZE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">err_TOO_SHORT</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
    <span class="n">gwy_file_abandon_contents</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
      The header is parsed using the
      <a class="link" href="gwymodule-tutorial-file.html#module-tutorial-file-portability" title="Portability">portable</a>
      binary buffer reading functions.
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="n">p</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">MAGIC_SIZE</span><span class="p">;</span>
<span class="n">simple</span><span class="p">.</span><span class="n">xres</span> <span class="o">=</span> <span class="n">gwy_get_guint16_le</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
<span class="n">simple</span><span class="p">.</span><span class="n">yres</span> <span class="o">=</span> <span class="n">gwy_get_guint16_le</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
<span class="n">simple</span><span class="p">.</span><span class="n">measure</span> <span class="o">=</span> <span class="n">gwy_get_gfloat_le</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
<span class="n">simple</span><span class="p">.</span><span class="n">z0</span> <span class="o">=</span> <span class="n">gwy_get_gfloat_le</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
<span class="n">simple</span><span class="p">.</span><span class="n">gain</span> <span class="o">=</span> <span class="n">gwy_get_gfloat_le</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
      Then we can create the data field and read the data into it.  Since
      <span class="application">Gwyddion</span> always works with values in base
      SI units, we have to convert the raw data values to physical values.
      If the file uses non-base units (which is common in SPM), we have to
      multiply the data by the corresponding factor: in this case with
      10<sup>-9</sup> as the physcial quantities are stored
      in nanometers in the file.
      Raw data conversion can be most easily performed with the convenience
      function <a href="../libgwyddion-gwyutils.html#gwy-convert-raw-data"><code class="function">gwy_convert_raw_data()</code></a>.  Sometimes it may be not sufficient
      so you can resort to the low-level GLib macros such as <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Byte-Order-Macros.html#GUINT16-FROM-LE:CAPS"><code class="function">GUINT16_FROM_LE()</code></a>
      or Gwyddion get-functions <a href="../libgwyapp-file-module-utils.html#gwy-get-gdouble-be"><code class="function">gwy_get_gdouble_be()</code></a>.
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6
7
8
9
10
11</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="n">simple</span><span class="p">.</span><span class="n">measure</span> <span class="o">*=</span> <span class="mf">1e-9</span><span class="p">;</span>
<span class="n">simple</span><span class="p">.</span><span class="n">z0</span> <span class="o">*=</span> <span class="mf">1e-9</span><span class="p">;</span>
<span class="n">simple</span><span class="p">.</span><span class="n">gain</span> <span class="o">*=</span> <span class="mf">1e-9</span><span class="p">;</span>
<span class="n">dfield</span> <span class="o">=</span> <span class="n">gwy_data_field_new</span><span class="p">(</span><span class="n">simple</span><span class="p">.</span><span class="n">xres</span><span class="p">,</span> <span class="n">simple</span><span class="p">.</span><span class="n">yres</span><span class="p">,</span>
                            <span class="n">simple</span><span class="p">.</span><span class="n">xres</span><span class="o">*</span><span class="n">simple</span><span class="p">.</span><span class="n">measure</span><span class="p">,</span>
                            <span class="n">simple</span><span class="p">.</span><span class="n">yres</span><span class="o">*</span><span class="n">simple</span><span class="p">.</span><span class="n">measure</span><span class="p">,</span>
                            <span class="n">FALSE</span><span class="p">);</span>
<span class="n">gwy_convert_raw_data</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">simple</span><span class="p">.</span><span class="n">xres</span><span class="o">*</span><span class="n">simple</span><span class="p">.</span><span class="n">yres</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="n">GWY_RAW_DATA_UINT16</span><span class="p">,</span> <span class="n">GWY_BYTE_ORDER_LITTLE_ENDIAN</span><span class="p">,</span>
                     <span class="n">gwy_data_field_get_data</span><span class="p">(</span><span class="n">dfield</span><span class="p">),</span>
                     <span class="n">simple</span><span class="p">.</span><span class="n">gain</span><span class="p">,</span> <span class="n">simple</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
      We have to set also the lateral and value units of the created data
      field (by default, the dimensions and values are unitless).
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6
7</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="n">unit</span> <span class="o">=</span> <span class="n">gwy_si_unit_new</span><span class="p">(</span><span class="s">&quot;m&quot;</span><span class="p">);</span>
<span class="n">gwy_data_field_set_si_unit_xy</span><span class="p">(</span><span class="n">dfield</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
<span class="n">g_object_unref</span><span class="p">(</span><span class="n">unit</span><span class="p">);</span>

<span class="n">unit</span> <span class="o">=</span> <span class="n">gwy_si_unit_new</span><span class="p">(</span><span class="s">&quot;m&quot;</span><span class="p">);</span>
<span class="n">gwy_data_field_set_si_unit_z</span><span class="p">(</span><span class="n">dfield</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
<span class="n">g_object_unref</span><span class="p">(</span><span class="n">unit</span><span class="p">);</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
      Our sample file format can only store topography channels, therefore
      the units are always meters.  For different types of channels the units
      have to be set accordingly.  Note that
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="n">unit</span> <span class="o">=</span> <span class="n">gwy_si_unit_new</span><span class="p">(</span><span class="s">&quot;nA&quot;</span><span class="p">);</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
      is exactly the same as
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="n">unit</span> <span class="o">=</span> <span class="n">gwy_si_unit_new</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">);</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
      In other words, the prefixes are ignored because <a href="../GwySIUnit.html#GwySIUnit-struct"><span class="type">GwySIUnit</span></a> represents
      the unit type and contains no magnitude information.  However, if the
      format stores the units as a string including the prefix we can use
      <a href="../GwySIUnit.html#gwy-si-unit-new-parse"><code class="function">gwy_si_unit_new_parse()</code></a> to obtain the corresponding power of 10 (and
      subsequently multiply data field values with the correct multiplier).
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="n">unit</span> <span class="o">=</span> <span class="n">gwy_si_unit_new_parse</span><span class="p">(</span><span class="s">&quot;nA&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">power10</span><span class="p">);</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
      Finally we create a new <a href="../GwyContainer.html#GwyContainer-struct"><span class="type">GwyContainer</span></a>, put the data field at
      <code class="literal">"/0/data"</code> and set the channel title
      <code class="literal">"/0/data/title"</code> (if the file contains explicit
      channel names, they are good candidates for a channel title, otherwise
      we settle for channel type as Topography or Current), and return the
      container.  The application then takes care of adding it to the data
      browser and showing it in a data window.  Calling
      <a href="../libgwyapp-file-module-utils.html#gwy-file-channel-import-log-add"><code class="function">gwy_file_channel_import_log_add()</code></a> for channel 0 adds a data operation
      log entry, noting that the data originated by import from the
      <code class="literal">"simple"</code> format.
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6
7
8
9
10
11
12</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="n">container</span> <span class="o">=</span> <span class="n">gwy_container_new</span><span class="p">();</span>
<span class="n">gwy_container_set_object_by_name</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="s">&quot;/0/data&quot;</span><span class="p">,</span> <span class="n">dfield</span><span class="p">);</span>
<span class="n">gwy_container_set_string_by_name</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="s">&quot;/0/data/title&quot;</span><span class="p">,</span>
                                 <span class="n">g_strdup</span><span class="p">(</span><span class="s">&quot;Topography&quot;</span><span class="p">));</span>

<span class="n">g_object_unref</span><span class="p">(</span><span class="n">dfield</span><span class="p">);</span>

<span class="n">gwy_file_channel_import_log_add</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;simple&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">);</span>

<span class="n">gwy_file_abandon_contents</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">return</span> <span class="n">container</span><span class="p">;</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

</div>
<div class="refsect1">
<a name="id-1.3.6.8"></a><h2>Loading More</h2>
<p>
      Real file formats often contain more information we would like to
      import.  First, they can contain several data fields (channels or even
      unrelated images).  We store the second data at
      <code class="literal">"/1/data"</code> and its title at
      <code class="literal">"/1/data/title"</code>, the third channel data at
      <code class="literal">"/2/data"</code>, etc.  The number sequence does not have
      to be contignuous but it is customary to make it so (in any case
      small integers should be used, do not start counting from 12758933).
    </p>
<p>
      Auxiliary information about the data as date and time of scanning, scan
      speed, tunneling current, tip oscillation frequency or user-defined
      comments can be stored to metadata.  Metadata is a nested <a href="../GwyContainer.html#GwyContainer-struct"><span class="type">GwyContainer</span></a>
      at <code class="literal">"/0/meta"</code> (for the first channel, the number of
      course corresponds to channel id).  The keys are simply names of the
      values, the values are always strings.  Note both keys and values have
      to be converted to UTF-8.
    </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6
7</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="n">meta</span> <span class="o">=</span> <span class="n">gwy_container_new</span><span class="p">();</span>
<span class="n">gwy_container_set_string_by_name</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="s">&quot;Comment&quot;</span><span class="p">,</span>
                                 <span class="n">g_strdup</span><span class="p">(</span><span class="n">myfile</span><span class="o">-&gt;</span><span class="n">user_comment</span><span class="p">));</span>
<span class="n">gwy_container_set_string_by_name</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="s">&quot;Tip oscillation frequency&quot;</span><span class="p">,</span>
                                 <span class="n">g_strdup_printf</span><span class="p">(</span><span class="s">&quot;%g Hz&quot;</span><span class="p">,</span> <span class="n">myfile</span><span class="o">-&gt;</span><span class="n">freq</span><span class="p">));</span>
<span class="n">gwy_container_set_object_by_name</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="s">&quot;/0/meta&quot;</span><span class="p">,</span> <span class="n">meta</span><span class="p">);</span>
<span class="n">g_object_unref</span><span class="p">(</span><span class="n">meta</span><span class="p">);</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

</div>
<div class="refsect1">
<a name="module-tutorial-file-portability"></a><h2>Portability</h2>
<p>
      Gwyddion runs on many platforms and can be compiled with various
      compilers.  File import is the area most affected by the differences
      between them, therefore certain care must be taken to make file modules
      work across all platforms.
    </p>
<div class="refsect2">
<a name="id-1.3.6.9.3"></a><h3>Text Data</h3>
<p>
        Text files can encode <span class="emphasis"><em>line ends</em></span>
        differently from the platform Gwyddion is running on.  Therefore
        opening files as text may lead to unexpected results.  One usually
        opens all files as binary and uses <a href="../libgwyddion-gwyutils.html#gwy-str-next-line"><code class="function">gwy_str_next_line()</code></a> to parse text
        files (or text parts of files) to lines.
      </p>
<p>
        The text representation of <span class="emphasis"><em>real numbers</em></span> is
        locale-dependent.  User's locale is unpredictable and a module must not
        set locale to arbitrary values because it would affect the rest of the
        application.  Therefore one has to use functions as <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-String-Utility-Functions.html#g-ascii-strtod"><code class="function">g_ascii_strtod()</code></a>
        to read real numbers portably.
      </p>
<p>
        Many text strings, like comments and remarks, are stored in an
        arbitrary <span class="emphasis"><em>character encoding</em></span>.
        Typically it is ISO 8895-1 (Latin1) or UTF-16, but sometimes more
        exotic encodings are used.  Since Gwyddion uses UTF-8 for all text data
        (like Gtk+ does) they must be converted, e.g., with <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Character-Set-Conversion.html#g-convert"><code class="function">g_convert()</code></a>.
      </p>
</div>
<hr>
<div class="refsect2">
<a name="id-1.3.6.9.4"></a><h3>Binary Data</h3>
<p>
        The canonical bad example is
      </p>
<div class="informalexample">
  <table class="listing_frame" border="0" cellpadding="0" cellspacing="0">
    <tbody>
      <tr>
        <td class="listing_lines" align="right"><pre>1
2
3
4
5
6
7</pre></td>
        <td class="listing_code"><pre class="programlisting"><span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">LONG</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">wchar_t</span> <span class="n">remark</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="p">}</span> <span class="n">header</span><span class="p">;</span>

<span class="n">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">header</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">header</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">filehandle</span><span class="p">);</span></pre></td>
      </tr>
    </tbody>
  </table>
</div>

<p>
        For start, <span class="type">LONG</span> is unlikely to exist on non-Microsoft
        platforms.  So should we fix it to <span class="type">long int</span>?  No, the
        <span class="emphasis"><em>type size</em></span> of classic C types (<span class="type">short</span>,
        <span class="type">long</span>, etc.) is different on different architectures (more
        precisely ABIs) and the standard prescribes only the lower limit. If we
        mean `32bit integer' we also have to express it in our code:
        <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Basic-Types.html#gint32"><span class="type">gint32</span></a>.
      </p>
<p>
        Likewise, <span class="type">wchar_t</span> size is not well-defined.   If the
        file comes from a Microsoft platform, where <span class="type">wchar_t</span> is
        used a lot, it is probably 16bit, so we write <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Unicode-Manipulation.html#gunichar2"><span class="type">gunichar2</span></a> instead
        and use <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Unicode-Manipulation.html#g-utf16-to-utf8"><code class="function">g_utf16_to_utf8()</code></a> to get UTF-8.
      </p>
<p>
        Then we have <span class="emphasis"><em>byte order</em></span>.  If we are on a platform
        with different native byte order than the file uses, we have to reverse
        the bytes in each multi-byte value.  GLib provides macros such as
        <a href="http://developer.gnome.org/doc/API/2.0/glib/glib-Byte-Order-Macros.html#GUINT16-FROM-LE:CAPS"><code class="function">GUINT16_FROM_LE()</code></a> to simplify this task.
      </p>
<p>
        And last but not least, different ABIs prescribe different
        <span class="emphasis"><em>structure padding</em></span>.  Typically there can be
        from 0 to 7 unused bytes between <em class="structfield"><code>c</code></em> and
        <em class="structfield"><code>i</code></em> fields.  While most compilers provide
        some packing <code class="literal">#pragma</code>s or other means to
        specify desired structure padding, the portability of these
        constructs is questionable at best.
      </p>
<p>
        The answer to (almost) all the problems above is: Don't do that then.
        Avoid direct reading of structures, read the data into a flat byte
        buffer instead and use the
        file module utils
        functions to obtain individual values.
      </p>
</div>
</div>
</div>
<div class="footer">
<hr>Generated by GTK-Doc V1.19</div>
</body>
</html>